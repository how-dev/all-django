# O problema N+1

> Esse problema √© um cl√°ssico e afeta todo o tipo de aplica√ß√£o de banco de dados, incluindo o ORM do Django.

## O que √©?
Resumidamente, √© quando a nossa aplica√ß√£o itera sobre os resultados de uma query. Por√©m, nesse processo, cada um desses resultados desencadeia queries adicionais no banco. Nesse caso o n√∫mero total de queries executadas no banco √© igual a N+1, onde o 1 representa a query inicial, que retorna uma lista. N representa cada uma das queries adicionais executadas para cada elemento da lista.

Exemplo de _N+1_ queries:
Digamos que o nosso app tenha um c√≥digo semelhante a:

````python
books = Book.objects.order_by("title")
for book in books:
    print(book.title, "by", book.author.name)
````
Esse c√≥digo est√° usando o **print()** por simplicidade, mas na maioria das aplica√ß√µes Django, o problema est√° nos serializers ou nos templates que acessam os relacionamentos das inst√¢ncias.

Vamos analisar as queries que esse bloco executa:

1. Na primeira linha, obtemos o QuerySet de Book. Os QuerySets s√£o lazy, ou seja, por enquanto, nenhuma query foi de fato executada em cima do banco.

2. Na linha 2, n√≥s iteramos sobre o QuerySet. Nesse caso, para cada itera√ß√£o o c√≥digo faz uma busca no banco para obter o elemento da itera√ß√£o atual, resultando no primeiro query

3. Na linha 3, n√≥s acessamos alguns atributos da inst√¢ncia de Book como title e author. O campo title est√° presente na tabela do Book portanto, esse acesso n√£o requer queries adicionais. Por√©m o atributo author est√° relacionado via Foreign Key. Para ter acesso a esse dado, √© necess√°rio executar uma nova query na tabela de Author, utilizando book.author_id.
Dessa forma, n√≥s executamos N queries para buscar os authors de cada book, onde N √© o n√∫mero de books. Isso pode se tornar um problema de performance porque cada query resulta num gasto computacional de comunica√ß√£o entre o servidor e o banco. Se n√£o tomarmos cuidado e tivermos uma quantidade grande de registros no banco de dados, a resposta do nosso servidor pode demorar minutos.

Usando a perspectiva do SQL, podemos examinar qual √© formato das queries que est√£o sendo executadas. A primeira query teria o seguinte formato:

````sql
SELECT
  id,
  title,
  author_id,
  ...
FROM book
ORDER BY title
````

As N queries subsequentes ter√≠am a seguinte forma:

````sql
SELECT
  id,
  name,
  ...
FROM author
WHERE id = %s
````

(Onde %s seria substitu√≠do por cada ID do author)

A repeti√ß√£o de m√∫ltiplas queries do tipo SELECT ... WHERE id = %s √© um sinal que pode indicar que a sua aplica√ß√£o est√° perdendo performance. Voc√™ pode observar esses sinais ativando o log das queries SQL feitas pela sua aplica√ß√£o.

### Exemplo de _2N+1_ queries:

Se acessarmos m√∫ltiplas foreign keys no loop, iremos aumentar o n√∫mero de queries. Por exemplo, se alterarmos o c√≥digo de forma a mostrar o pa√≠s do autor:

````python
books = Book.objects.order_by("title")
for book in books:
    print(
        book.title,
        "by",
        book.author.name,
        "from",
        book.author.country.name,
    )
````

Para ter acesso ao country de author.country √© necess√°rio rodar mais uma query dentro do loop. Ent√£o agora temos o dobro de queries üò±

### Exemplo de _N*M+N+1_ queries:

Se aninharmos loops, teremos problemas de performance maiores. No pr√≥ximo exemplo, estamos executando m√∫ltiplas queries para cada query em N.

Imagine que o nosso modelo permite adicionar m√∫ltiplos autores por livro. Nesse caso, ter√≠amos que ajustar o nosso c√≥digo:

````python
books = Book.objects.order_by("title")
for book in books:
    print(book.title, "by: ", end="")
    names = []
    for author in book.authors.all():
        names.append(f"{author.name} from {author.country.name}")
    print(", ".join(names))
````

A linha 5 executa N queries para obter o authors do book. A linha 6 acessa o country para cada um dos authors. Se existe uma m√©dia de M authors para cada book, o nosso servidor far√° N*M queries.

Quando N e/ou M s√£o n√∫meros pequenos, o n√∫mero total de queries poder√° n√£o influenciar muito na performance. Por√©m √© poss√≠vel observar um n√∫mero muito grande de queries conforme N e M aumentam. Se adicion√°ssemos mais loops aninhados, ter√≠amos mais um fator multiplicativo para formar o n√∫mero total de queries.

Para resolvermos este problema, podemos usar duas ferramentas:
### select_related("campo_relacional"):
> Bom para campos relacionais que n√£o s√£o t√£o extensos

### prefetch_related("campo_relacional") (prefer√≠vel):
> Bom para campos relacionais mais extensos. Ele faz duas queries no banco em problemas N+1, mas evita
> dados duplicados e √© melhor para rela√ß√µes maiores.